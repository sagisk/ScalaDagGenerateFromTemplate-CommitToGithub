
Akka HTTP modules implement a full server- and client-side HTTP stack on top of 
akka-actor and akka-stream.  
The high-level, routing API of Akka HTTP provides a DSL to describe HTTP “routes” 
and how they should be handled. 
- Each route is composed of one or more level of Directives that narrows down to handling one specific type of request.

Example:
A route can narrow down the path of the request to match only "/hello" via `path("hello")`,
then it can narrow down the HTTP request to `GET` and then compete the request with a response
message that will be sent back as HTTP OK in response body e.g.,
`complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, "<h1>Say hello to akka-http</h1>"))`

Transforming request and response bodies to be used in your application is done separately from the route declarations, 
in **marshallers**. With Marshallers:
- complete a request with any kind of object as long as there is an implicit marshaller available in scope.

Another Pros of Akka HTTP is that streamsing can be used with both request and response bodies.
Moreover, streaming responses will be backpressured by the client i.e.
- server will not push data faster than the client can handle

Akka HTTP server can handle connections or individual requests with:
- `HttpRequest`
- `HttpResponse`
both part of `akka-http-core` module.

# Data Types & Abstractions
## HTTP Model
**HttpRequest** consists of:
- a method (GET, POST, etc.)
- a URI (see URI model for more information)
- a seq of headers
- an entity (body data)
- a protocol

Note that all parameters of `HttpRequest.apply` have default values.

**HttpResponse**
- a status code
- a `Seq` of headers
- an entity (body data)
- a protocol

**HttpEntity**
- carries data bytes of a message
- Content-Type
- Content-Length (if known)
Akka HTTP offers 5 different kinds of entities:

`HTTPEntity.Strict`
- used f the amount of data is “small” and already available in memory
- wraps `ByteString` and represents unchunked entity with known `Content-Lenght`

`HttpEntity.Default`
- unchunked HTTP/1.1 message entity
- presents data as `Source[ByteString, _]`
- can be only materialized once
- use when if the data is generated by a streaming data source and the size of the data is known

`HttpEntity.Chunked`
- model for HTTP/1.1 chunked content (i.e. sent with `Transfer-Encoding: chunked`).
- individual chunks are presented as a Source[HttpEntity.ChunkStreamPart]
- `ChunkStreamPart` is either a non-empty `Chunk` or a `LastChunk` containing optional trailer headers
- use for an entity of unknown length

`HttpEntity.CloseDelimited`
- unchunked entity of unknown length that is implicitly delimited by closing the connection (Connection: close).
- content data are presented as a Source[ByteString, _]. 
- since the connection must be closed after sending an entity of this type it can only be used on the server-side for sending a response.
- usually, use `HttpEntity.Chunked` instead

`HttpEntity.IndefiniteLength`
- streaming entity of unspecified length for use in a `Multipart.BodyPart`

## URI model
Akka HTTP offers its own specialised `Uri` model class which is tuned for both performance and idiomatic usage.
When you try to parse a URI string, Akka HTTP internally creates an instance of the `Uri` class,
which holds the modeled URI components inside.
You can built uri as
- `Uri("http://www.ietf.org/rfc/rfc2396.txt")`
or
- `Uri.from(scheme = "http", host = "www.ietf.org", path = "/rfc/rfc2396.txt")`

`Uri.from` method can get:
- scheme
- host
- path
- queryString

When an invalid URI string is passed to `Uri()` - an `IllegalUriException` is thrown.

## Marshaling (serialization)
Marshalling is the process of converting a higher-level (object) structure into some kind of lower-level representation, often a “wire format”.
In Akka HTTP, marshalling means the conversion of an object of type T into a lower-level target type, e.g. a `MessageEntity`
or a full `HttpRequest` or `HttpResponse`

Marshalling of instances of type `A` into instances of type `B` is performed by a `Marshaller[A, B]`
`Marshaller[A, B]` is not a plain function A => B but rather essentially a function `A => Future[List[Marshalling[B]]]`
- `Future`: Marshallers are not required to synchronously produce a result, so instead they return a future, which allows for asynchronicity in the marshalling process.
- `List`: Marshallers can offer several target representations of `A` e.g. Marshaller can offer a JSON and XML representation.
- `Marshalling[B]`: Rather than returning an instance of `B` directly marshallers first produce a `Marshalling[B]`.
  allows for querying the MediaType and potentially the HttpCharset that the marshaller will produce before the actual marshalling is triggered.

